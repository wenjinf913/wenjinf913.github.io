{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/01/01/hello-world/"},{"title":"使用Hexo搭建自己的博客网站","text":"first bloghello world!","link":"/2021/10/04/test/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"}],"pages":[{"title":"Linked List","text":"21. Merge Two Sorted Lists Solution: Create a dummy node to simplify merging and initialize a pointer p starting at the dummy. Traverse both lists using pointers p1 and p2. Compare their values and append the smaller node to the merged list by updating p.next. Move the respective pointer (p1 or p2) and advance p. Once one list is exhausted, append the remaining nodes of the other list to p.next. Return the merged list starting from dummy.next, skipping the dummy node. Time Complexity: O(M+N) Space Complexity: O(1) 12345678910111213141516171819class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: p1 = list1 p2 = list2 dummy = ListNode(-1) p=dummy while p1!=None and p2!=None: if p1.val &gt; p2.val: p.next = p2 p2 = p2.next else: p.next = p1 p1 = p1.next p = p.next if p1!=None: p.next = p1 elif p2!=None: p.next=p2 return dummy.next 86. Partition List Note: Ensure you break the next link for each node during traversal to avoid cycles and maintain the partition order correctly. 1234567891011121314151617181920class Solution: def partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]: less = ListNode(-1) greater = ListNode(-1) l = less g = greater p=head while p!=None: if p.val&lt;x: l.next=p l = l.next else: g.next=p g = g.next temp = p.next p.next = None p = temp l.next = greater.next return less.next 23. Merge k Sorted Lists 123456789101112131415161718import heapqclass Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: pq = [] dummy = ListNode(-1) p = dummy if not lists: return None for i,head in enumerate(lists): if head is not None: heapq.heappush(pq, (head.val, i, head)) while pq: val, i, head = heapq.heappop(pq) p.next = head p = p.next if head.next is not None: heapq.heappush(pq, (head.next.val, i, head.next)) return dummy.next 19. Remove Nth Node From End of List Solution: Create a dummy node and set both slow and fast pointers to it, linking dummy to the head. Move the fast pointer n+1 steps ahead to maintain a gap of n nodes between fast and slow. Move both slow and fast one step at a time until fast reaches the end of the list. Update slow.next to skip the target node by pointing it to slow.next.next. Return dummy.next as the new head. 12345678910111213class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: dummy = ListNode(-1) slow = dummy fast = dummy dummy.next = head for _ in range(n+1): fast = fast.next while fast!=None: fast=fast.next slow=slow.next slow.next = slow.next.next return dummy.next Note: Edge Case - Single Node List: If the list has only one node and n = 1, the dummy node ensures the code handles it properly by returning None. Gap of n+1: Moving fast ahead by n+1 steps is critical to ensure that when fast reaches the end, slow is at the node before the one to be removed. 142. Linked List Cycle II Solution: 123456789101112131415161718192021222324252627class Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: &quot;&quot;&quot; 3-2: L 2--4-2: C 2-meeting point = x slow: L+x fast: 2(L+x) 2(L+x)-(L+x) = nC L+x=nC L=nC-x &quot;&quot;&quot; slow, fast = head, head while fast!=None and fast.next!=None: slow = slow.next fast = fast.next.next if slow==fast: break if not fast or fast.next==None: return None fast = slow slow = head while fast!=slow: fast = fast.next slow = slow.next return slow 160. Intersection of Two Linked Lists Solution: Initialize two pointers, p1 and p2, at the heads of the two lists, headA and headB. Traverse the lists with p1 and p2. If a pointer reaches the end of its list, redirect it to the head of the other list. Continue until p1 equals p2, which will either be the intersection node or None if there is no intersection. Return p1 as the result. Note: Handling No Intersection: If the two lists do not intersect, both p1 and p2 will eventually reach None at the same time after traversing both lists, ensuring the loop exits correctly. Time Complexity: O(m+n), where m and n are the lengths of the two lists, as each pointer traverses both lists once. 12345678910111213class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: p1, p2 = headA, headB while p1!=p2: if p1 is None: p1 = headB else: p1 = p1.next if p2 is None: p2 = headA else: p2 = p2.next return p1","link":"/CodeCraft-Leetcode-Beyond/Linked-List.html"},{"title":"CodeCraft: Leetcode &amp; Beyond","text":"Linked-List Linked List Project","link":"/CodeCraft-Leetcode-Beyond/index.html"},{"title":"projects","text":"","link":"/projects/index.html"},{"title":"about","text":"","link":"/about/index-1.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"readings","text":"","link":"/readings/index.html"}]}